= Qu'est-ce qu'une Monade ?
:toc:
:toclevels: 3
:toc-placement: preamble
:lb: pass:[<br> +]
:imagesdir: ./images
:icons: font
:stem:
:source-highlighter: highlightjs

By Thomas SCHWENDER (Softeam StarTech Java)

== Explications

Commençons par une définition courte :

____
Une monade peut être vue comme un *amplificateur de type*, permettant la *composition de fonctions* sur ce nouveau "type amplifié".
____

Là, on respire un grand coup, et on se dit que cela ne fait qu'une petite phrase à expliquer ;) 

Et, avant même de se lancer dans les explications sur le sujet, un rappel : historiquement, *les monades nous viennent de la programmation fonctionnelle*. +
Et, la programmation fonctionnelle : 

* *adore la composition*, le chaînage de Fonctions (avec un grand "F") 
* *déteste les effets de bords*, dont nos petites Exceptions Java sont un bel exemple...

Avec ces rappels bien en tête, on attaque :

== Amplicateur de type

Je rapproche ce concept d'amplificateur de type avec notre bon vieux https://en.wikipedia.org/wiki/Decorator_pattern[Design Pattern Décorateur].

Le concept est finalement simple : nous venons "wrapper" un type, afin d'en étendre les fonctionnalités.

Pour faire cela ? +
Dans le but de *gérer au mieux les effets de bords* ! (d'où les rappels précédents). +
En programmation fonctionnelle, *une fonction doit garantir la même output pour une input donnée*, principe qui n'est pas respecté dès lors que l'on utilise des exceptions.

Cas pratique avec la monade Optional (ou Maybe).

Soit les fonctions :
[stem]
++++
f(x) = 42 * x
g(x,y) = x / y
++++
 



  A monad is an "amplifier" of types that obeys certain rules and which has certain operations provided.

  First, what is an "amplifier of types"? By that I mean some system which lets you take a type and turn it into a more special type. For example, in C# consider Nullable<T>. This is an amplifier of types. It lets you take a type, say int, and add a new capability to that type, namely, that now it can be null when it couldn't before.

  What are the "certain rules"? Briefly, that there is a sensible way for functions on the underlying type to work on the amplified type such that they follow the normal rules of functional composition.


composition de fonction

  the three operations you need: turning a value into an amplified value, turning an amplified value into a value, and transforming a function on unamplified values into a function on amplified values.

Voir la MayBe monade



The bind operation on a monad is what makes composition of functions on amplified types work.

== Composition de fonctions


== Resources

* http://stackoverflow.com/a/2704795/1809195[Monad in plain English? (For the OOP programmer with no FP background)]
* http://stackoverflow.com/a/2704795/1809195[Why do we need monads?] : très bonne explication par l'exemple, incrémentale
* http://blog.sigfpe.com/2006/08/you-could-have-invented-monads-and.html[You could have invented Monads]
* https://medium.com/@sinisalouc/demystifying-the-monad-in-scala-cc716bb6f534#.68n4rnifd[Demystifying the Monad in Scala]
* https://www.mkyong.com/java8/java-8-flatmap-example/ : de la pratique autour du `flatMap` (bind)
* https://www.quora.com/What-are-monads-in-functional-programming-and-why-are-they-useful[What are monads in functional programming and why are they useful?] : bons exemples détaillés de plusieurs monades très connues, voir également la petite section "Why?"


